#ifndef JOS_INC_TRAP_H
#define JOS_INC_TRAP_H

/* Trap numbers
 * These are processor defined: */
#define T_DIVIDE     0      /* divide error */
#define T_DEBUG      1      /* debug exception */
#define T_NMI        2      /* non-maskable interrupt */
#define T_BRKPT      3      /* breakpoint */
#define T_OFLOW      4      /* overflow */
#define T_BOUND      5      /* bounds check */
#define T_ILLOP      6      /* illegal opcode */
#define T_DEVICE     7      /* device not available */
#define T_DBLFLT     8      /* double fault */
/* #define T_COPROC  9 */   /* reserved (not generated by recent processors) */
#define T_TSS       10      /* invalid task switch segment */
#define T_SEGNP     11      /* segment not present */
#define T_STACK     12      /* stack exception */
#define T_GPFLT     13      /* general protection fault */
#define T_PGFLT     14      /* page fault */
/* #define T_RES    15 */   /* reserved */
#define T_FPERR     16      /* floating point error */
#define T_ALIGN     17      /* aligment check */
#define T_MCHK      18      /* machine check */
#define T_SIMDERR   19      /* SIMD floating point error */

/* These are arbitrarily chosen, but with care not to overlap
 * processor defined exceptions or interrupt vectors. */
#define T_SYSCALL   48      /* system call */
#define T_DEFAULT   500     /* catchall */

#define IRQ_OFFSET  32  /* IRQ 0 corresponds to int IRQ_OFFSET */

/* Hardware IRQ numbers. We receive these as (IRQ_OFFSET+IRQ_WHATEVER) */
#define IRQ_TIMER        0
#define IRQ_KBD          1
#define IRQ_SERIAL       4
#define IRQ_SPURIOUS     7
#define IRQ_IDE         14
#define IRQ_ERROR       19

#ifndef __ASSEMBLER__

#include <inc/types.h>

struct pushregs {
    /* registers as pushed by pusha */
    uint32_t reg_edi; //0
    uint32_t reg_esi; //4
    uint32_t reg_ebp; //8
    uint32_t reg_oesp;      /* Useless */
    uint32_t reg_ebx; //16 (0x10)
    uint32_t reg_edx; //20 (0x14)
    uint32_t reg_ecx; //24 (0x18)
    uint32_t reg_eax; //28 (0x1c)
} __attribute__((packed));

struct trapframe {
    struct pushregs tf_regs; //8 * 4 = 32 (0-28)
    uint16_t tf_es;//32 (0x20)
    uint16_t tf_padding1; 
    uint16_t tf_ds;//36
    uint16_t tf_padding2; 
    uint32_t tf_trapno; //40 (0x28)
    /* below here defined by x86 hardware */
    uint32_t tf_err; //44
    uintptr_t tf_eip; //48 (0x30)
    uint16_t tf_cs; //52 (0x34)
    uint16_t tf_padding3;
    uint32_t tf_eflags; //56
    /* below here only when crossing rings, such as from user to kernel */
    uintptr_t tf_esp; //60 (0x3c) 
    uint16_t tf_ss;
    uint16_t tf_padding4; //64
} __attribute__((packed));

struct u_trapframe {
    /* information about the fault */
    uint32_t utf_fault_va;  /* va for T_PGFLT, 0 otherwise */
    uint32_t utf_err;
    /* trap-time return state */
    struct pushregs utf_regs;
    uintptr_t utf_eip;
    uint32_t utf_eflags;
    /* the trap-time stack to return to */
    uintptr_t utf_esp;
} __attribute__((packed));

#endif /* !__ASSEMBLER__ */

#endif /* !JOS_INC_TRAP_H */
